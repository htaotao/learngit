<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // https://juejin.im/post/5b83cb5ae51d4538cc3ec354#comment
        /*
        * resolve : 将Promise对象的状态从 Pending(进行中) 变为 Fulfilled(已成功)
        * reject : 将Promise对象的状态从 Pending(进行中) 变为 Rejected(已失败)
        * resolve 和 reject 都可以传入任意类型的值作为实参，
        * 表示 Promise 对象成功（Fulfilled）和失败（Rejected）的值
        * */
        const PENDING = 'PENDING';
        const FULFILLED = 'FULFILLED';
        const REJECTED = 'REJECTED';
        const isFunction = variable => typeof variable === 'function';
        class MyPromise {
            constructor (handle) {
                if (!isFunction(handle)) {
                    throw new Error('MyPromise must accept a function as a parameter')
                }
                // 添加状态
                this._status = PENDING;
                // 添加值
                this._value = undefined;
                // 执行handle
                try {
                    handle(this._resolve.bind(this), this._reject.bind(this))
                } catch (e) {
                    this._reject(e)
                }
            }
            _resolve(val) {
                if (this._status !== PENDING) return;
                this._status = FULFILLED;
                this._value = val
            }
            _reject(err) {
                if (this._status !== PENDING) return;
                this._status = REJECTED;
                this._value = err
            }
        }

        /*
        * Promise 对象的 then 方法接受两个参数：
        * onFulfilled 和 onRejected 都是可选参数。
        * 如果 onFulfilled 或 onRejected 不是函数，其必须被忽略
        * */
        /*
        * 如果 onFulfilled 或者 onRejected 返回一个值 x ，
        * 则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)
        * */
        let promise1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve()
            }, 1000)
        });
        promise2 = promise1.then(res => {
            // 返回一个普通值
            return '这里返回一个普通值'
        });
        promise2.then(res => {
            console.log(res) // 1秒后打印出：这里返回一个普通值
        });

        let promise1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve()
            }, 1000)
        });
        promise2 = promise1.then(res => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('这里返回一个Promise')
                }, 2000)
            })
        });
        promise2.then(res => {
            console.log(res) // 3秒后打印出：这里返回一个Promise
        });

        /*
        * 如果 onFulfilled 或者onRejected 抛出一个异常 e ，
        * 则 promise2 必须变为失败（Rejected），并返回失败的值 e
        * */
        let promise1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('success')
            }, 1000)
        });
        promise2 = promise1.then(res => {
            throw new Error('这里抛出一个异常e')
        });
        promise2.then(res => {
            console.log(res)
        }, err => {
            console.log(err) // 1秒后打印出： 这里抛出一个异常e
        });

        /*
        * 如果onFulfilled 不是函数且 promise1 状态为成功（Fulfilled），
        * promise2 必须变为成功（Fulfilled）并返回 promise1 成功的值，
        * */
        let promise1 = new Promise((resolve, rejuct) => {
            setTimeout(() => {
                resolve('success')
            }, 1000)
        });
        promise2 = promise1.then('这里的onFulfilled本来是一个函数，但现在不是');
        promise2.then(res => {
            console.log(res) // 1秒后打印出：success
        }, err => {
            console.log(err)
        });

        /*
        * 如果 onRejected 不是函数且 promise1 状态为失败（Rejected），
        * promise2必须变为失败（Rejected） 并返回 promise1 失败的值
        * */
        let promise1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('fail')
            }, 1000)
        });
        promise2 = promise1.then(res => res, '这里的onRejected本来是一个函数，但现在不是');
        promise2.then(res => {
            console.log(res)
        }, err => {
            console.log(err) // 1秒后打印出：fail
        });

        // 完善MyPromise
        class MyPromise {
            constructor (handle) {
                if (!isFunction(handle)) {
                    throw new Error('MyPromise must accept a function as a parameter')
                }
                // 添加状态
                this._status = PENDING;
                // 添加值
                this._value = undefined;
                // 添加成功回调函数队列
                this._fulfilledQueues = [];
                // 添加失败回调函数队列
                this._rejectQueues = [];
                // 执行handle
                try {
                    handle(this._resolve.bind(this), this._reject.bind(this))
                } catch (e) {
                    this._reject(e)
                }
            }
            _resolve(val) {
                if (this._status !== PENDING) return;
                this._status = FULFILLED;
                this._value = val
            }
            _reject(err) {
                if (this._status !== PENDING) return;
                this._status = REJECTED;
                this._value = err
            }
            then(onFulfilled, onRejected){
                const {_value, _status} = this;
                // 返回一个新的Promise对象
                return new MyPromise((onFulfilledNext, onRejectedNext) => {
                    // 封装一个成功时执行的函数
                    let fulfilled = value => {
                        try {
                            if (!isFunction(onFulfilled)){
                                onFulfilledNext(value)
                            } else {
                                let res = onFulfilled(value);
                                if (res instanceof MyPromise) {
                                    // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                                    res.then(onFulfilledNext, onRejectedNext)
                                } else {
                                    //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                                    onFulfilledNext(res)
                                }
                            }
                        } catch (e) {
                            // 如果函数执行出错，新的Promise对象的状态为失败
                            onRejectedNext(e)
                        }
                    };
                    // 封装一个失败时执行的函数
                    let rejected = error => {
                        try {
                            if (!isFunction(onRejected)) {
                                onRejectedNext(error)
                            } else {
                                let res = onRejected(error);
                                if (res instanceof MyPromise) {
                                    // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                                    res.then(onFulfilledNext, onRejectedNext)
                                } else {
                                    //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                                    onFulfilledNext(res)
                                }
                            }
                        } catch (e) {
                            // 如果函数执行出错，新的Promise对象的状态为失败
                            onRejectedNext(e)
                        }
                    };
                    switch (_status) {
                        // 当状态为pending时，将then方法
                        case PENDING:
                            this._fulfilledQueues.push(onFulfilled);
                            this._rejectQueues.push(onRejected);
                            break;
                        // 当状态发生改变时，立即执行对应的回调函数
                        case FULFILLED:
                            onFulfilled(_value);
                            break;
                        case REJECTED:
                            onRejected(_value);
                            break;
                    }
                });
                // 未完待续

            }
        }

    </script>
</body>

</html>
